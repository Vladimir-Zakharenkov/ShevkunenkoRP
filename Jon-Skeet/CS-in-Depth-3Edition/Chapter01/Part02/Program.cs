#region Russian

/*
 1.1.Простой тип данных

 В этой главе я позволю компилятору С# предпринимать удивительные вещи, не
 говоря о том, как он это делает, а лишь кратко указывая на то, что он делает или почему.
 Это единственный раз, когда я не буду объяснять, каким образом все работает.
 или пытаться охватить сразу более одного шага. На самом деле все наоборот - план
 заключается в том, чтобы произвести впечатление, а не обучать. Если при чтении этого
 раздела у вас не возникло хотя бы легкого волнения по поводу того, что можно делать
 с помощью С#, то возможно эта книга не для вас. Однако, скорее всего, вы готовы
 ринуться в исследование деталей работы этих магических трюков, о которых пойдет речь
 в остальных частях книги.

 Пример, который будет использоваться, несколько надуман - в нем преследуется
 цель втиснуть максимально возможное количество новых средств в как можно более
 короткий фрагмент кода. Это избитый пример, но зато он должен быть знаком. Да, речь
 идет о примере с товаром, наименованием и ценой, представляющим собой аналог
 программы “Hello, world” в области электронной коммерции. Мы посмотрим, как
 решаются разнообразные задачи, и каким образом новые версии С# позволяют упростить эти
 решения и сделать их более элегантными. Вы не увидите преимуществ С#5 вплоть до
 конца главы, но это отнюдь не уменьшит их важность.

 1.1.1. Тип Product в С# 1
 Мы начнем с определения типа, представляющего товар, и затем приступим к манипуляциям
 с ним. Здесь пока что нет ничего выдающегося - просто инкапсуляция пары свойств.
 Чтобы упростить дальнейшую демонстрацию, мы создадим список предопределенных
 товаров.

 В листинге 1.1 показано, как можно было бы реализовать тип на С# 1. После этого
 мы посмотрим, как переписать этот код во всех последующих версиях С#. Мы будем
 следовать такому шаблону и в остальных фрагментах кода. Учитывая, что я пишу это
 в 2013 году, скорее всего, код выглядит для вас довольно знакомым, но всегда полезно
 оглянуться назад и оценить, насколько существенно продвинулся язык в своем развитии.

*/

// Листинг 1.1. Тип Product (С# 1)

using System.Collections;
using System.ComponentModel;

[Description("Listing 1.1")]
public class Product
{
    string name;
    public string Name
    {
        get
        {
            return name;
        }
    }

    decimal price;
    public decimal Price
    {
        get
        {
            return price;
        }
    }

    public Product(string name, decimal price)
    {
        this.name = name;
        this.price = price;
    }

    public static ArrayList GetSampleProducts()
    {
        ArrayList list = new ArrayList();

        list.Add(new Product("West Side Story", 9.99m));
        list.Add(new Product("Assassins", 14.99m));
        list.Add(new Product("Frogs", 13.99m));
        list.Add(new Product("Sweeney Todd", 10.99m));

        return list;
    }

    public override string ToString()
    {
        return string.Format("{0}: {1:C}", name, price);
    }

    public static void Main()
    {
        ArrayList product = Product.GetSampleProducts();

        // Корректное отображение символа рубля.
        System.Console.OutputEncoding = System.Text.Encoding.Unicode;

        foreach (var item in product)
        {
            System.Console.WriteLine(item.ToString());
        }

        System.Console.ReadKey();
    }
}

/*
 В листинге 1.1 нет ничего такого, что было бы трудно понять - в конце концов, это
 всего лишь код С# 1. Тем не менее, здесь демонстрируются три ограничения.

 На этапе компиляции тип АггаyList не имеет каких-либо сведений о том, что
 в нем содержится. В список, создаваемый внутри метода GetSampleProducts(),
 может быть случайно добавлена, скажем, строка, и компилятор не заметит этого.

 Мы предоставили открытые средства получения (get) для свойств, а это значит,
 что соответствующие им средства установки (set), если бы они понадобились,
 пришлось бы также делать открытыми.

 Присутствует масса незначительных деталей при создании свойств и переменных
 - код, который усложняет довольно простую задачу инкапсуляции строки и
 десятичного значения.

 Давайте посмотрим, каким образом С# 2 поможет улучшить ситуацию.

*/

#endregion