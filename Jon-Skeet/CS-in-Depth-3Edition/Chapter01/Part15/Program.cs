#region Russian
/*

1.3. Обработка отсутствия данных

Мы рассмотрим две формы отсутствия данных. Сначала мы обсудим сценарий, при
котором информация просто не доступна, а затем посмотрим, как устранять информацию 
из вызовов методов, используя стандартные значения.

1.3.1. Представление неизвестной цены

В этот раз кода будет немного, но я уверен, что проблема вам знакома, особенно если
вы долго имели дело с базами данных. Представьте, что список товаров содержит не
только товары, продаваемые в настоящий момент, но и те, которые еще не поступили.
В ряде случаев их цена может быть неизвестна. Если бы тип decimal был ссылочным,
то для представления неизвестной цены можно было бы применить null, но поскольку
decimal является типом значения, так поступать нельзя. Как тогда представить
неизвестную цену в С# 1?

Существуют три распространенных альтернативы.

Создание оболочки ссылочногоо типа для типа decimal.

Поддержка отдельного булевского флага, который будет указывать, известна ли цена

Использование для представления неизвестной цены “магического значения"
(например, decimal.MinValue).

Надеюсь, что вы согласитесь с тем, что ни одна из указанных альтернатив не выглядит 
особо привлекательной. Фокус в том, что проблему можно решить путем добавления
единственного символа к объявлениям переменных и свойств. В .NET 2.0 решение
упростилось за счет появления структуры Nullable<T>, и в С# 2 предлагается дополнительный 
"синтаксический сахар", который позволяет изменить объявление свойства
следующим образом:

decimal? price:
public decimal? Price
{
get { return price; }
private set { price = value; }
}

Тип параметра конструктора изменен на decimal?, в результате чего в качестве
аргумента можно передавать значение null, а также применять в коде класса оператор
вроде Price = null;. Смысл значения null изменяется со “специальной ссылки,
которая не указывает на какой-либо объект” на “специальное значение любого типа,
допускающего null, которое позволяет представить отсутствие полезных данных”, при
этом все ссылочные типы и все типы, основанные на Nullable<Т>, считаются типами
допускающими null.

Код получается намного более выразительным, чем при любом другом решении.
Остальная часть кода функционирует без изменений - товар с неизвестной ценой будет
трактоваться как дешевле, чем $10, из-за особенностей обработки значений типов,
допускающих null, в операциях сравнения "больше". Для проверки, известна ли цена,
можно сравнить ее с null или воспользоваться свойством HasValue, поэтому вывод
всех товаров с неизвестными ценами в С# З осуществляется с помощью кода, приведенного
в листинге 1.14.

*/

// Листинг 1.14. Отображение товаров с неизвестными ценами (С# З)

using System;
using System.Linq;
using System.Collections.Generic;

public class Product
{
    string name;
    public string Name
    {
        get
        {
            return name;
        }

        private set
        {
            name = value;
        }
    }

    decimal? price;
    public decimal? Price
    {
        get
        {
            return price;
        }

        private set
        {
            price = value;
        }
    }

    public Product(string name, decimal? price = null)
    {
        Name = name;
        Price = price;
    }

    public static List<Product> GetSampleProducts()
    {
        List<Product> list = new List<Product>();

        list.Add(new Product("West Side Story", 9.99m));
        list.Add(new Product("Assassins", 14.99m));
        list.Add(new Product("Frogs", 13.99m));
        list.Add(new Product("Sweeney Todd", 10.99m));

        list.Add(new Product("C# 9 and .NET 5 – Modern Cross-Platform Development"));
        list.Add(new Product("C# Game Programming Cookbook for Unity 3D"));
        return list;

    }

    public override string ToString()
    {
        return string.Format("{0}: {1:C}", name, price);
    }

    public static void Main()
    {
        List<Product> products = Product.GetSampleProducts();

        // Корректное отображение символа рубля.
        Console.OutputEncoding = System.Text.Encoding.Unicode;

        foreach (Product product in products.Where(p => p.Price == null))
        {
            Console.WriteLine(product.Name);
        }

        Console.ReadKey();
    }
}

/*

Код С# 2 будет похож на код из листинга 1.12, но только придется выполнить проверку
на предмет null. в анонимном методе:

List<Product> products = Product.GetSampleProducts();
products.FinfAll(delegate(Product p) {return p.Price == null; }).ForEach(Console.WriteLine);

Версия С# З не предлагает в данном случае каких-либо изменений, но в С# 4 реализовано 
средство, которое имеет к этому отношение, по крайней мере, косвенное.

1.3.2. Необязательные параметры и стандартные значения

Иногда указывать все необходимые значения для метода нежелательно, например,
когда отдельный параметр почти всегда имеет одно и то же значение. Традиционное
решение предусматривала перегрузку такого метода, однако в С# 4 появились необязательные 
параметры, которые позволяют поступать проще.

В версии типа Product на С# 4 имеется конструктор, принимающий название и
цену товара. Цене можно назначить десятичный тип, допускающий null, как в С# 2 и
С# 3, но давайте предположим, что цены большинства товаров не известны. Было бы
неплохо иметь возможность инициализировать товар примерно так:

Product p = new Product("Unreleased product");

До появления С# 4 для этой цели в классе Product пришлось бы определить новую
перегруженную версию конструктора. Версия С# 4 позволяет объявить для параметра
price стандартное значение (в этом случае null):

public Product(string name, decimal? price = null)
{
this.name = name;
this.price = price
}

При объявлении необязательного параметра всегда должно указываться константное
значение. Оно не обязательно должно быть равно null; просто в данной ситуации null
оказалось подходящим стандартным значением. Требование о том, что стандартное 
значение является константой, применимо к параметру любого типа, хотя для ссылочных
типов, отличных от строк, вы ограничены null как единственным доступным константным 
значением.

На рис. 1.4 представлена сводка по рассмотренной ранее эволюции обработки отсутствующих 
данных в разных версиях С#.

Рассмотренные до сих пор средства полезны, но ничего особенного собой не представляют. 
А теперь перейдем к кое-чему более интересному: LINQ.

*/

#endregion